**前期准备**：

软件：matlab2019a和carsim2016版本

# 一、无人驾驶系统架构

![image-20231005141202100](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231005141202100.png)

**1.全局路径规划模块**：规划出一条车辆从当前位置到目标地点之间成本最低的可行路线

目前在全局路径规划应用较多的算法有蚁群算法、遗传算法、A* 算法等。这些算法依靠事先得到的高精度地图，将路网表示为一个有向图，每个向量有一个权值，该值与穿过路段的成本相对应，之后就可以在有向图上找到一条成本最低的路径

网址：[PathFinding.js (qiao.github.io)](https://qiao.github.io/PathFinding.js/visual/)



**2)环境感知模块: 由毫米波雷达、激光雷达、相机和GPS定位装置等组成作用:**

检测到周围的环境信息，包括**路面、静态物体和动态物体**三方面。根据这些主富的场景信息进行即时定位与地图构建，并将得到的实时地图传递给下一层



**3)行为决策和轨迹规划模块:确定车辆的具体行为动作以及可行的参考轨迹**
行为决策子模块:根据交通规则、当前车辆的状态以及实时地图提供的周围环境信息，决定车辆所要采取的行为，包括跟随、超车、换道、左转、右转等等。

轨迹规划子模块: 在综合所有信息的基础上，轨迹规划子模块则要估计出安全空间，并且得到条精确可行的参考轨迹，该轨迹要保证与障碍物无碰撞、符合交通规则、对于底层的控制器可执行，并且满足乘客对于舒适度的要求



**4)轨迹跟踪模块**：保证无人驾驶车辆在规划出来的参考轨迹上行驶



路径规划的组成部分：



![image-20231124200754760](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231124200754760.png)

全局规划

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231124201027174.png" alt="image-20231124201027174" style="zoom:67%;" />



行为决策

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231124201239519.png" alt="image-20231124201239519" style="zoom:67%;" />



动作规划

（轨迹规划和速度规划）

![image-20231124201703844](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231124201703844.png)

# 二、车辆领域基本知识和定义( 入门 )

参考资料：[Apollo代码学习(三)—车辆动力学模型_汽车动力学模型-CSDN博客](https://blog.csdn.net/u013914471/article/details/83018664)

运动学模型：[自动驾驶控制算法（一）坐标系，车辆运动学模型 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/461687192)

动力学模型：[自动驾驶控制算法（二）车辆二自由度动力学模型 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/462315968)

## 2.1 前置概念

参考资料：[航向角，横摆角，车辆质心侧偏角，前轮侧偏角（这又可以分为在轮胎坐标系下和车辆坐标系下的前轮侧偏角哦），前轮转角_车辆侧偏角是_KingkWinner的博客-CSDN博客](https://blog.csdn.net/m0_54639819/article/details/120309360?ops_request_misc=%7B%22request%5Fid%22%3A%22169710171616800192230311%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169710171616800192230311&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120309360-null-null.142^v96^pc_search_result_base6&utm_term=横摆角&spm=1018.2226.3001.4187)

**坐标系**的知识
大地坐标系 : Y X (先忽略z轴 )
车体坐标系 :y x( 先忽略z轴 )

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231005142727525.png" alt="image-20231005142727525" style="zoom:67%;" />

参考资料：[【自动驾驶】Frenet坐标系与Cartesian坐标系（一）-CSDN博客](https://blog.csdn.net/weixin_42301220/article/details/125211683?ops_request_misc=%7B%22request%5Fid%22%3A%22169744722216800211540004%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169744722216800211540004&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125211683-null-null.142^v96^pc_search_result_base6&utm_term=frenet坐标系&spm=1018.2226.3001.4187)

**笛卡尔坐标系右手系(车辆领域 ）**
**右手定则**来判定z轴的正向:

右手握住z轴，当右手的四指从x轴正向以pai/2角度转向y轴正向时，大拇指的方向就是z轴的正向。[左手定则同理]



**frenet坐标系**

Frenet坐标系使用道路的中心线作为参考线，**使用参考线的切线向量和法线向量建立坐标系**。相比笛卡尔坐标系，Frenet坐标系简化了路径规划问题。

![image-20231016171920801](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231016171920801.png)

三个角度的**具体定义**
1.**质心侧偏角**:车辆质心速度方向与车辆纵轴方向的夹角（就是图中的角1）

2.**横摆角**: 车辆纵轴方向与大地坐标系x轴之间的夹角

**3.航向角**：车辆质心速度与大地坐标系x轴之间的夹角（就是图中的角3）



**横向误差**：车辆质心距车道中心线的距离

**航向误差**：实际航向与期望航向之间的差异或偏差







## 2.2 车辆的运动学模型

参考资料:[Apollo代码学习(二)—车辆运动学模型_apollo 运动学-CSDN博客](https://blog.csdn.net/u013914471/article/details/82968608)

### 2.2.1 单车模型

单车模型(Bicycle Model)将左/右前轮合并为一个点，位于A点；将左/右后轮合并为一个点，位于B点；点C为车辆质心点。

![image-20231011154543893](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231011154543893.png)



![image-20231011155604961](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231011155604961.png)

其中，O为OA、OB的交点，是车辆的瞬时滚动中心，线段OA、OB分别垂直于两个滚动轮的方向；

**β 为滑移角（Tire Slip Angle），指车辆速度方向和车身朝向两者间所成的角度，ψ 为航向角（Heading Angle），指车身与X轴的夹角。**



### 2.2.2**车辆运动学模型**

运动学是从几何学的角度研究物体的运动规律，包括物体在空间的位置、速度等随时间而产生的变化，因此，车辆运动学模型应该能反映车辆位置、速度、加速度等与时间的关系。在车辆轨迹规划过程中应用运动学模型，可以使规划出的轨迹更切合实际，满足行驶过程中的运动学几何约束，且基于运动学模型设计出的控制器也能具有更可靠的控制性能。

结论：

![image-20231011161400324](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231011161400324.png)

即通过控制前轮转角，后轮转角以及速度，就能知道x方向速度，y方向速度以及航向角变化率



### 2.2.3  阿克曼转向几何

阿克曼转向几何是一种为了解决交通工具转弯时，内外转向轮路径指向的圆心不同的几何学。

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231011162559323.png" alt="image-20231011162559323" style="zoom: 80%;" />



### 2.2.4.最小转向半径

omega_cmd(车辆的角速度)在此函数中求得：
$$
w=v/(\frac{tan(\delta )}{L} )=v/R
$$












### 2.2.5 小结

![image-20231011164646543](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231011164646543.png)



## 2.3 **车辆动力学模型**

动力学模型：[自动驾驶控制算法（二）车辆二自由度动力学模型 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/462315968)



动力学主要研究作用于物体的力与物体运动的关系，车辆动力学模型一般用于分析车辆的平顺性和车辆操纵的稳定性。对于车来说，研究车辆动力学，主要是研究车辆轮胎及其相关部件的受力情况。比如**纵向速度控制**，通过控制轮胎转速实现；**横向航向控制**，通过控制轮胎转角实现。

**单车模型(Bicycle Model)**
建立模型时，应尽可能使模型简单易用，且能真实反映车辆特性，搭建车辆模型多基于单车模型(Bicycle Model)，使用单车模型需做如下假设：

1. 不考虑车辆在Z轴方向的运动，只考虑XY水平面的运动，如图1所示；
2. 左右侧车轮转角一致，这样可将左右侧轮胎合并为一个轮胎，以便于搭建单车模型，如图2所示；
3. 车辆行驶速度变化缓慢，忽略前后轴载荷的转移；
4. 车身及悬架系统是刚性的

单车模型假设的前提下，搭建车辆的动力学模型

![img](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/20181011141510629)

如图2所示，o x y z为固定于车身的车辆坐标系，O X Y 为固定于地面的惯性坐标系。单车模型的车辆具有2个自由度：绕z轴的横摆运动，和沿x轴的纵向运动。纵向指沿物体前进方向，横向(或侧向)指垂直纵向方向。
![image-20231010203852263](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231010203852263.png)

 横向误差 lateral_error
 横向误差率lateral_error_rate
 航向误差 heading_error
 航向误差率 heading_error_rate



如图5，为横向误差计算的示意图：

![image-20231011120817305](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231011120817305.png)

![image-20231019173911703](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231019173911703.png)

横纵向误差计算

参考资料：[Apollo代码学习(五)—横纵向控制_apollo纵向控制 论文-CSDN博客](https://blog.csdn.net/u013914471/article/details/83748571)

其中：e1横向误差的计算需要使用到二维坐标变换公式

横向误差结论：

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231011152516379.png" alt="image-20231011152516379" style="zoom: 80%;" />

![image-20231019173954218](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231019173954218.png)

参考资料：[二维坐标系的转换 - 漠刀凡尘 - 博客园 (cnblogs.com)](https://www.cnblogs.com/softhal/p/5648463.html)

至此，车辆的动力学模型搭建完成



## 2.4 欧拉角和四元数







# 三、MPC知识分享

MPC(模型预测控制 Model Predictive Control)

课程（非常容易懂）：[【控制】模型预测控制MPC05控制律优化二次规划.103324202_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1HQ4y1P7bJ/?p=5&spm_id_from=pageDriver&vd_source=e6a100138906f3892c6413488ca8e688)

## 3.1 最优化控制和基本概念

### 1.最优控制

最优化问题的目标是找到满足约束条件的最优解，即使得目标函数取得最大值或最小值的变量取值。

**研究动机**：在约束条件（物理限制）下达到最优的系统表现

![image-20231008170007039](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231008170007039.png)

可以看到如图所示：

轨迹1更为舒适

![image-20231008170130454](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231008170130454.png)

对于单输入单输出的系统来说，对于e^2的积分越小，追踪的效果就越好，因为结果与期望相差越小

而对u^2积分越小，就说明需要的能耗越小



**代价/目标函数**（函数J）

**<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231008170706314.png" alt="image-20231008170706314" style="zoom:50%;" />**

**MIMO（多输入多输出系统）**

函数J是目标/代价函数

![image-20231008170928020](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231008170928020.png)

举例：

![image-20231008171314597](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231008171314597.png)

**其中Q,R是调节矩阵，q<sub>1</sub>和q<sub>2</sub>、r<sub>1</sub>、r<sub>2</sub>**



## 3.2.MPC基本概念

参考资料：[Apollo代码学习(六)—模型预测控制(MPC)_模型预测控制代码-CSDN博客](https://blog.csdn.net/u013914471/article/details/83824490)

参考书籍：[龚建伟, 姜岩, 徐威. 无人驾驶车辆模型预测控制[M\]. 北京理工大学出版社, 2014.](https://download.csdn.net/download/u013914471/10739948)

https://zhuanlan.zhihu.com/p/541110725

### 0.为什么需要使用MPC

以差分底盘小车为研究对象，更传统的输出轨迹方法是“控制-定位-控制”的模式，如DWA。但是计算机的控制有时间延迟，第一次发出速度指令并进行定位时小车已经向前走了一个距离，而下一时刻发送的速度指令是基于上次定位的信息，也就是说控制是滞后的。MPC可以根据过去的信息以及载体模型，推算出未来一定时间内的最优控制策略，从而解决了控制滞后的问题。

### 1.基本介绍

**模型预测控制主要包含三个要素**

1.  **预测模型**:预测模型是模型预测控制的基础。其主要功能是根据对象的历史信息和未来输入，预测系统未来的输出。对预测模型的形式没有做严格的限定，状态方程、传递函数这类传统的模型都可以作为预测模型。对于线性稳定系统，阶跃响应、脉冲响应这类非参数模型，也可以直接作为预测模型使用。
2. **滚动优化**:模型预测控制通过某一性能指标的最优来确定控制作用但优化不是一次离线进行，而是反复在线进行的。这就是滚动优化的含义，也是模型预测控制区别于传统最优控制的根本点。
3. **反馈校正**:为了防止模型失配或者环境干扰引起控制对理想状态的偏离，在新的采样时刻，首先检测对象的实际输出，并利用这一实时信息对基于模型的预测结果进行修正，然后再进行新的优化（autoware上没有用到反馈校正的部分）

简单理解：	

<img src="C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231009115251183.png" alt="image-20231009115251183" style="zoom:67%;" />

k轴为当前状态，左侧为过去状态，右侧为将来状态。

MPC控制原理框图

![image-20231013121132481](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231013121132481.png)

### 2运动学模型的建立

Latex公式编辑器

[在线LaTeX公式编辑器-编辑器 (latexlive.com)](https://www.latexlive.com/)

阿克曼模型如下

![image-20231013121940845](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231013121940845.png)

建立车辆运动学模型[f1,f2,f3]
$$
\left\{\begin{matrix} 
\dot{X} =V_{r} cos\varphi  \\
\dot{Y} =V_{r} sin\varphi  \\
\dot{\varphi} =V_{r} tan\delta _{ f}
\end{matrix}\right.
$$
状态变量和控制量分别是
$$
\xi=\begin{bmatrix}  
  X  \\  

  Y  \\
  \varphi 
  
\end{bmatrix} ,

u=\begin{bmatrix}  
  V_{r}   \\  

  \delta _{f}  \\
 
  
\end{bmatrix}
$$
由此可以看出状态空间方程是**非线性的**
$$
\dot{\xi} =f(\xi,u)-----(1)
$$
线性模型预测控制较非线性模型预测控制有更好的实时性，且更易于分析和计算，那么需要**将模型进行线性化**,如下面这种形式
$$
\dot{\tilde{\xi} }=A\tilde{\xi}+B\tilde{u}
$$



### **3.MPC模型的构建**

#### 1.模型线性化

线性化方法

<img src="C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231013150600376.png" alt="image-20231013150600376" style="zoom: 80%;" />

采用泰勒展开式进行展开

任意参考点为
$$
(\xi _{r} ,u _{r})
$$
得到一阶泰勒展开式
$$
\dot{\xi}  =f(\xi_{r},u_{r})+\frac{\partial f}{\partial \xi}(\xi_{r}-\xi)+\frac{\partial f}{\partial u}(u_{r}-u)-----(2)
$$
(2)-(1)得
$$
\tilde{\xi} =\xi-\xi_{r} \\
 \dot{\tilde{\xi} } =\dot{{\xi} }-\dot{\xi_{r}} =\frac{\partial f}{\partial \xi}(\xi_{r}-\xi)+\frac{\partial f}{\partial u}(u_{r}-u)------(3) \\
$$
即
$$
\dot{\tilde{\xi} }=\frac{\partial f}{\partial \xi}\tilde{\xi}+\frac{\partial f}{\partial u}\tilde{u}
$$
即
$$
\dot{\tilde{\xi} }=A\tilde{\xi}+B\tilde{u}
$$
**至此，完成状态空间方程的线性化**

其中，
$$
\left\{\begin{matrix} 
\tilde{\xi} =\xi-\xi_{r}= \begin{bmatrix}
 X-X_{r}   \\
 Y-Y_{r}  \\
 \varphi -\varphi _{r} 
\end{bmatrix}\\
\tilde{u} =u-u_{r}=\begin{bmatrix}
v_{r}   \\
\delta _{r}  \\
\end{bmatrix}
\end{matrix}\right.\\
其中u_{r}为0，因为此时参考是位置上的参考，对速度和转角无要求\\
X、Y、\varphi是目标值，X_{r}、Y_{r}、\varphi_{r}是上层planning给的
$$


A，B均是雅可比矩阵

![image-20231013164457421](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231013164457421.png)

#### 2. 离散化

$$
\dot{\tilde{\xi}} =\frac{\tilde{\xi}(k+1)-\tilde{\xi}(k)}{T} =A\tilde{\xi}(k)+B\tilde{u}(k)
$$

即
$$
{\tilde{\xi}}(k+1) =(I+TA)\tilde{\xi}(k)+TB\tilde{\xi}(u)=\tilde{A}\tilde{\xi}(k)+\tilde{B}\tilde{u}(k) \\
通过状态变量\tilde{\xi}(k)以及控制量\tilde{u}(k)得到{\tilde{\xi}}(k+1)，就能看出模型的预测功能
$$
其中
$$
\left\{\begin{matrix} 
\tilde{A}=I+TA=\begin{bmatrix}
  1& 0 &-Tv_{r}sin\varphi_{r}   \\
  v& 1 &Tv_{r}cos\varphi_{r}  \\
  0& 0 &1
\end{bmatrix} \\
\tilde{B}=TB=\begin{bmatrix}
 Tcos\varphi_{r} & 0\\
 Tsin\varphi_{r} & 0\\
 \frac{Ttan\varphi_{r}}{l}  & \frac{TV_{r} }{lcos^{2}\delta _{f}  }
\end{bmatrix}
\end{matrix}\right.
$$
得到线性时变模型


$$

$$


#### 3.预测模型

以预测时域Np=4，控制时域Nc=3举例
$$
\begin{equation}
\begin{aligned}
\tilde{\xi}(k+1)&=\tilde{A}\tilde{\xi}(k)+\tilde{B}\tilde{u}(k) \\

\tilde{\xi}(k+2)&=\tilde{A}^{2} \tilde{\xi}(k)+\tilde{A}\tilde{B}\tilde{u}(k)+\tilde{B}\tilde{u}(k+1) \\
\tilde{\xi}(k+3)&=\tilde{A}^{3} \tilde{\xi}(k)+\tilde{A}^{2}\tilde{B}\tilde{u}(k)+\tilde{A}\tilde{B}\tilde{u}(k+1)+\tilde{B}\tilde{u}(k+2) \\
\tilde{\xi}(k+4)&=\tilde{A}^{4} \tilde{\xi}(k)+\tilde{A}^{3}\tilde{B}\tilde{u}(k)+\tilde{A}^{2}\tilde{B}\tilde{u}(k+1)+\tilde{A}\tilde{B}\tilde{u}(k+2)+\tilde{B}\tilde{u}(k+3) \\
\end{aligned}
\end{equation}
$$
**那么就能得到预测方程**
$$
Y=\phi \tilde{\xi}(k)+\theta U(k)
$$
其中
$$
\left\{\begin{matrix} 
\begin{equation}
\begin{aligned}
Y&= \begin{bmatrix}  
  \tilde{\xi}(k+1)  \\  
  \tilde{\xi}(k+2)  \\  
  \vdots  \\  
 \tilde{\xi}(k+N_{p} )  
\end{bmatrix} 
，
\phi=\begin{bmatrix}  
  \tilde{A}  \\  
  \tilde{A}^{2}   \\  
  \vdots  \\  
 \tilde{A}^{N_{p}}  )  
\end{bmatrix} ，

\tilde{\xi}(k+1)=\begin{bmatrix}  
  \tilde{x}_{k}   \\  
  \tilde{y}_{k}   \\    
  \tilde{\varphi }_{k}    
\end{bmatrix}  \\

\theta &= \begin{bmatrix}  
  \tilde{B} & 0 & \cdots & 0 \\  
  \tilde{A}\tilde{B} & \tilde{B} & \cdots & 0 \\  
  \vdots & \vdots & \ddots & \vdots \\  
  \tilde{A}^{N_{p}-1} \tilde{B} &   \tilde{A}^{N_{p}-2} \tilde{B} & \cdots &\tilde{B}
\end{bmatrix} ,

U= \begin{bmatrix}  
  u(k)  \\  
  u(k+1)  \\  
  \vdots  \\  
 u(k+N_{c} )  
\end{bmatrix} 
\end{aligned}
\end{equation}
\end{matrix}\right.
$$


#### 4.优化（QP问题求解）

目标:
$$
\left\{\begin{matrix}
Y\to Y_{ref}\\
min U

\end{matrix}\right.
$$
代价函数：J
$$
\begin{equation}
\begin{aligned}
J&=min(Y-Y_{ref} )^{T} Q(Y-Y_{ref})+U^{T} QU \\
假设 \\
E&=\phi \xi -\phi \xi_{r} =\phi \xi -Y_{ref} \\
\end{aligned}
\end{equation}
$$
那么
$$
Y-Y_{ref}=E+\theta U
$$
则代价函数J化为
$$
\begin{equation}
\begin{aligned}
min(E+\theta U)^{T} Q(E+\theta U)+U^{T} QU \\
=E^{T}QE+(\theta U)^{T}Q(\theta U)+2E^{T}Q(\theta U)+U^{T} QU\\


\end{aligned}
\end{equation}
$$
由于第一项与U值没有关系，是关于U的常数所以代价函数J
$$
\begin{equation}
\begin{aligned}
J&=(\theta U)^{T}Q(\theta U)+2E^{T}Q(\theta U)+U^{T} QU\\
&= U^{T}\theta^{T}Q\theta U+2E^{T}Q(\theta U)+U^{T} QU\\
&=U^{T}（\theta^{T}Q\theta+R)U+2E^{T}Q\theta U\\
&=\frac{1}{2} U^{T}HU+f^{T}U
\end{aligned}
\end{equation}
$$
从而化成了二次规划的标准形式,包含优化约束
$$
\left\{\begin{matrix}
min\frac{1}{2} U^{T}HU+f^{T}U\\
lb\le U\le ub
\end{matrix}\right.
$$
从而求出最优的控制序列
$$
U= \begin{bmatrix}  
  u(k)  \\  
  u(k+1)  \\  
  \vdots  \\  
 u(k+N_{c} )  
\end{bmatrix}
$$
<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231013201019373.png" alt="image-20231013201019373" style="zoom: 50%;" />

**控制序列算了Nc步，但是只用到了第一步**

总结：

![image-20231014102149900](https://cdn.jsdelivr.net/gh/su-ron/image/imgimage-20231014102149900.png)

## 3.3 基于autoware解读MPC算法（详细）

参考资料：

[Autoware的MPC源码解析（一）mpc_waypoints_converter解析_autoware mpcfollow 曲率-CSDN博客](https://blog.csdn.net/cyj1871/article/details/98490799)

[自动驾驶控制算法实例之模型预测控制（MPC）--从模型推导到代码实现（以Autoware为例） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/358836526)

### 1.节点分析数据流向

通过autoware mpc源码的节点图可知，

在mpc源码中包含了两个节点，一个是/mpc_waypoints_converter，另一个是/mpc_follower。关系如下图所示。

其中话题/final_waypoints订阅的是最近路径点之后的路径信息，/closest_waypoint订阅的是发布局部路径信息（只包含最近路径点前50个后10个点），/base_waypoints订阅的是接受最近路径点的序号（消息格式为autoware_msgs::Lane)

/mpc_waypoints_converter,/closest_waypoint,/base_waypoints订阅的数据经过节点/mpc_waypoints_converter处理，发布mpc_waypoints路径点序列

![img](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/20190829113651365.png)

**/vehicle_status**订阅的是当前转向角和当前车速的信息

**/current_pose**订阅的是车辆pose信息(包含姿态的位置消息position以及姿态的旋转消息orientation四元数)

**/ctrl_cmd**发布接收/mpc_waypoints_converter节点的局部路径信息

**/twist_raw**发布接收/mpc_waypoints_converter节点目标控制指令：目标转向角，目标纵向速度，目标加速度

![image-20231016175615503](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231016175615503.png)

### 2.控制模型

包含**动力学模型**（ dynamic model）和**运动学模型**（ kinematics model ）两类。同时考虑到方向盘转角的执行滞后特性，所以在Autoware框架中，MPC算法运用的控制模型主要有三种

![image-20231014103239700](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231014103239700.png)



在低速运行的场景中，运动学模型即可满足要求，因此，本篇主要以运动学模型为基础，介绍MPC算法的实现流程。

![image-20231016164937926](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231016164937926.png)

其中：（x，y） 分别代表车辆横纵向位置信息；$\theta $ 代表车辆的航向信息； $\delta$<sub>f</sub>代表车辆的前轮转角； L 代表车辆的轴距； v代表车速。

在vehicle_model_bicycle_kinematics_no_delay模型中，状态量为：[横向位移偏差，航向偏差],控制量 u=[$\delta$<sub>f</sub>] （前轮转角)

**横向误差计算公式参考如下：**

![image-20231019175527588](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231019175527588.png)

**代码实现中状态量为：[横向位移偏差，航向偏差]，**即**[err_lat, yaw_err]，主要是对该系统需要进行线性化处理**,控制量 u=[$\delta$<sub>f</sub>] （前轮转角）

![image-20231019175234403](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231019175234403.png)

**代码实现**：

![image-20231016114723535](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231016114723535.png)



### 3.控制模型的线性化

对系统进行线性化变化

![image-20231014110614014](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231014110614014.png)

平衡点 (0,0) 附近求导即可求得最后的线性化模型为：

![image-20231014110719907](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231014110719907.png)

![image-20231016115319686](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231016115319686.png)

**线性化后MPC系统状态量是x=[err_lat,yaw_err],控制量u为车辆转角$\delta$<sub>f</sub>.**

```C++
KinematicsBicycleModelNoDelay::~KinematicsBicycleModelNoDelay(){};
void KinematicsBicycleModelNoDelay::calculateDiscreteMatrix(Eigen::MatrixXd &Ad, Eigen::MatrixXd &Bd,
                                                     Eigen::MatrixXd &Cd, Eigen::MatrixXd &Wd, const double &dt)
{
    auto sign = [](double x) { return (x > 0.0) - (x < 0.0); };

    /* Linearize delta around delta_r (referece delta) */
    double delta_r = atan(wheelbase_ * curvature_);
    if (abs(delta_r) >= steer_lim_)
        delta_r = steer_lim_ * (double)sign(delta_r);
    double cos_delta_r_squared_inv = 1 / (cos(delta_r) * cos(delta_r));

    Ad << 0.0, velocity_,
          0.0, 0.0;
    Eigen::MatrixXd I = Eigen::MatrixXd::Identity(dim_x_, dim_x_);
    Ad = I + Ad * dt;

    Bd << 0.0, velocity_ / wheelbase_ * cos_delta_r_squared_inv;
    Bd *= dt;

    Cd << 1.0, 0.0,
          0.0, 1.0;

    Wd << 0.0,
        -velocity_ / wheelbase_ * delta_r * cos_delta_r_squared_inv;
    Wd *= dt;
}
```

### 4.控制系统离散化

autoware采用双线性（Tustin）变换以及欧拉法对系统进行离散化。

对于欧拉变化，其变换公式如下：

![image-20231014111346477](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231014111346477.png)

在vehicle_model_bicycle_kinematics_no_delay模型中，主要采用**欧拉变换**来获得相应的离散化模型。最后，我们即可获取MPC所需的状态空间模型。

![image-20231014111313928](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231014111313928.png)

其中
$$
\left\{\begin{matrix}
A_{d} =I+AT \\
B_{d} =BT \\
W_{d} =WT
\end{matrix}\right.
$$
其中，由阿克曼转角定理不难推知期望的前轮转角输入$\delta$<sub>f</sub>ref为：

![image-20231016120516783](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231016120516783.png)

其中，阿克曼转角定理为：

阿克曼几何的简化版 – 车辆单轨模型（自行车模型）

<img src="C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231016121136323.png" alt="image-20231016121136323" style="zoom:50%;" />

好处就在于它简化了前轮转向角与后轴将遵循的曲率之间的几何关系，其关系如下式所示：
$$
t a n ( δ ) =\frac{L}{R} \\所以，δ=arctan\frac{L}{R} 
$$
其中 δ表示前轮的转角，L为轴距，R则为在给定的转向角下后轴遵循着的圆的半径。这个公式能够在较低速度的场景下对车辆运动做估计。



**当获得了系统的离散化状态方程，即可利用状态方程进行多步态的状态预测**

**离散化后的状态方程可重写为**(**这里没搞懂**)

![image-20231014112151925](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231014112151925.png)

若预测时域为 N ，则预测状态矩阵表达式为（7）：

![image-20231014112221930](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231014112221930.png)

代码实现中，预测时域为70步

![image-20231016153825093](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231016153825093.png)

将上述状态预测矩阵重写为：

![image-20231014112251685](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231014112251685.png)

### 5.二次规划求解最优解

代价函数的目标是：
$$
\left\{\begin{matrix}
U\to U_{ref}\\
min X_{ex}

\end{matrix}\right.
$$
建立cost function，如下所示：
$$
J = X_{ex}' * Qex * X_{ex} + (U_{ex} - U_{refex})' * Rex * (U_{ex} - U_{refex})
$$
**Qex矩阵和Rex矩阵是权重矩阵**

代码实现：

![image-20231016152104174](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231016152104174.png)

代价函数化简后：

![image-20231014112322582](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231014112322582.png)

其中：

![image-20231014112338891](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231014112338891.png)



限制条件：
$$
\left\{\begin{matrix}
lb<U<ub \\
lbA<A<ub\\
\end{matrix}\right.\\
其中lb代表最小转角，ub代表最大转角
$$

​          对根据离散线性化模型建立动态预测方程，目标函数优化求解得到转角控制序列Uex，优化求解时约束为轮胎的转角范围。

​                                                     ![image-20231016175932533](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231016175932533.png)

​         接着对转角控制序列Uex进行**限幅（饱和）操作**

![image-20231016175916714](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231016175916714.png)

​         对控制序列进行滤波

![image-20231016180007293](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231016180007293.png)

​         最终选取控制序列中的第一个控制量经过滤波处理到转角命令(steer_cmd)；根据控制序列前两个值计算转角变化速度(steer_vel_cmd);

![image-20231016174636179](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231016174636179.png)

​        根据轨迹序列(其中，轨迹序列是通过局部路径信息获得的）获得速度（vel_cmd)和加速度（acc_cmd),        

![image-20231016174724034](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231016174724034.png)

​       根据求得的转角控制序列求解预测轨迹并发送可视化消息。





## 3.4  代码实现介绍

![image-20231020121940930](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231020121940930.png)

### 1.callbackRefPath函数

接受/mpc_waypoints_converter节点发布的局部路径信息,当in_waypoints（/mpc_waypoints_converter）有信息来的时候，调用回调函数MPCFollower::callbackRefPath进行处理

```c++
sub_ref_path_ = nh_.subscribe(in_waypoints, 1, &MPCFollower::callbackRefPath, this);
```

```c++
void MPCFollower::callbackRefPath(const autoware_msgs::Lane::ConstPtr &msg)
{
  //跟踪路径点序列
  current_waypoints_ = *msg;
  DEBUG_INFO("[MPC] path callback: received path size = %lu, line: %d", current_waypoints_.waypoints.size(), __LINE__);

  if (current_behavior_ == 0) // INITIAL_STATE
  {
    // publishControlCommands(0.0, 0.0, steer_cmd_prev_, 0.0); // publish brake
    return;
  }

  MPCTrajectory traj;

  /* calculate relative time */
  std::vector<double> relative_time;
  //获取到一个对应于路径点序列的时间序列。
  MPCUtils::calcPathRelativeTime(current_waypoints_, relative_time, fabs(lastest_yaw_error_deg_));
  DEBUG_INFO("[MPC] path callback: received path size = %lu", current_waypoints_.waypoints.size());
  DEBUG_INFO("[MPC] path callback: relative_time.size() = %lu, front() = %f, back() = %f",
             relative_time.size(), relative_time.front(), relative_time.back());

  /* resampling */
  //按照给定距离重新对路径点进行采样
  //获得参考的轨迹
  MPCUtils::convertWaypointsToMPCTrajWithDistanceResample(current_waypoints_, relative_time, traj_resample_dist_, traj);
  //计算相对时间，设置路径起点的时间为0，之后根据每个路径点的目标速度以及点与点之间的距离计算出车辆到达每个路径点时相对于起点的时间
  MPCUtils::convertEulerAngleToMonotonic(traj.yaw);
  //此函数是对路径点的航向角进行修改，保证相邻路径点的航向角的差值处于-pi～pi之间
  DEBUG_INFO("[MPC] path callback: resampled traj size() = %lu", traj.relative_time.size());

  /* path smoothing */
  //对重置的路径进行光滑处理（可通过修改enable_path_smoothing_变量的值选择是否执行此处理）
  if (enable_path_smoothing_)
  {
    for (int i = 0; i < path_smoothing_times_; ++i)
    {
      if (!MoveAverageFilter::filt_vector(path_filter_moving_ave_num_, traj.x) ||
          !MoveAverageFilter::filt_vector(path_filter_moving_ave_num_, traj.y) ||
          !MoveAverageFilter::filt_vector(path_filter_moving_ave_num_, traj.yaw) ||
          !MoveAverageFilter::filt_vector(path_filter_moving_ave_num_, traj.vx))
      {
        ROS_WARN("[MPC] path callback: filtering error. stop filtering");
        return;
      }
    }
  }

  /* calculate yaw angle */
  //重新求解航向角（可通过修改enable_yaw_recalculation_变量的值选择是否执行此操作）
  if (enable_yaw_recalculation_)
  {
    MPCUtils::calcTrajectoryYawFromXY(traj);
    MPCUtils::convertEulerAngleToMonotonic(traj.yaw);
  }

  /* calculate curvature */
  //计算每个路径点的曲率
  MPCUtils::calcTrajectoryCurvature(traj, curvature_smoothing_num_);
  const double max_k = *max_element(traj.k.begin(), traj.k.end());
  const double min_k = *min_element(traj.k.begin(), traj.k.end());
  DEBUG_INFO("[MPC] path callback: trajectory curvature : max_k = %f, min_k = %f", max_k, min_k);

  /* add end point with vel=0 on traj for mpc prediction */
  //设置路径的最后一个路径点的目标速度为0
  const double mpc_predict_time_length = (mpc_param_.prediction_horizon + 1) * mpc_param_.prediction_sampling_time;
  const double end_velocity = 0.0;
  traj.vx.back() = end_velocity; // also for end point
  traj.push_back(traj.x.back(), traj.y.back(), traj.z.back(), traj.yaw.back(),
                 end_velocity, traj.k.back(), traj.relative_time.back() + mpc_predict_time_length);

  if (!traj.size())
  {
    ROS_ERROR("[MPC] path callback: trajectory size is undesired.");
    DEBUG_INFO("size: x=%lu, y=%lu, z=%lu, yaw=%lu, v=%lu,k=%lu,t=%lu", traj.x.size(), traj.y.size(),
               traj.z.size(), traj.yaw.size(), traj.vx.size(), traj.k.size(), traj.relative_time.size());
    return;
  }

  ref_traj_ = traj;

  /* publish trajectory for visualize */
  //发布路径信息用于观察（可视化）
  visualization_msgs::Marker markers;
  convertTrajToMarker(ref_traj_, markers, "ref_traj", 0.0, 0.5, 1.0, 0.05);
  pub_debug_filtered_traj_.publish(markers);
};
```



callbackRefPath函数把接收到的“/mpc_waypoints"话题消息传递给”current_waypoints"

定义MPCTrajectory类型的traj对象用来存放处理后的轨迹点，其成员如下：

```c++
  std::vector<double> x;             //存放x位置的vector
  std::vector<double> y;             //存放y位置的vector
  std::vector<double> z;             //存放z位置的vector
  std::vector<double> yaw;           //存放航向角的vector
  std::vector<double> vx;            //存放速度的vector
  std::vector<double> k;             //存放曲率的vector
  std::vector<double> relative_time; //存放相对时间的vector
```

计算路径点的相对时间如下文1所示；

重采样后得到初步的轨迹（traj)如下文（2）所示；使用移动平均滤波器对轨迹点进行圆滑处理；

calcTrajectoryYawFromXY计算轨迹点中的航向角如下文（3）所示；

利用三点的圆拟合计算曲率；检查最终得到的参考轨迹是否合格如下文（4）所示；



**（1）计算路径点的相对时间**

输入：

current_waypoints_:当前路径(path)

输出：

relative_time:相对时间序列（path_time)

```c++
void MPCUtils::calcPathRelativeTime(autoware_msgs::Lane &path, std::vector<double> &path_time, const double& error_yaw_deg)
{
  double t = 0.0;
    
  double decceleration_factor = 1;
  static double last_deccel_factor_ = 1;
  static double last_velocity_ = 0.0;
  static double pcurrent = 0;
  static double plast = 1;
  double err_yaw_threshold_deg = 30;
  if (fabs(error_yaw_deg) > err_yaw_threshold_deg)
  {
    decceleration_factor = 1 - fabs(error_yaw_deg) / 90 + (err_yaw_threshold_deg / 90);
    if (fabs(last_deccel_factor_ - decceleration_factor) > 0.05)
    {
      plast -= 0.15;
      pcurrent += 0.15;
    }
    else
    {
      plast += 0.05;
      pcurrent -= 0.05;
    }
    plast = std::min(plast, 1.0);
    plast = std::max(plast, 0.0);
    pcurrent = std::min(pcurrent, 1.0);
    pcurrent = std::max(pcurrent, 0.0);
    decceleration_factor = plast * last_deccel_factor_ + pcurrent * decceleration_factor;
    // printf("deccelerate_factor %f error_yaw_deg: %f\n", decceleration_factor, error_yaw_deg);
  }
  path_time.clear();
  path_time.push_back(t);
  for (int i = 0; i < (int)path.waypoints.size() - 1; ++i)
  {
    const double x0 = path.waypoints.at(i).pose.pose.position.x;
    const double y0 = path.waypoints.at(i).pose.pose.position.y;
    const double z0 = path.waypoints.at(i).pose.pose.position.z;
    const double x1 = path.waypoints.at(i + 1).pose.pose.position.x;
    const double y1 = path.waypoints.at(i + 1).pose.pose.position.y;
    const double z1 = path.waypoints.at(i + 1).pose.pose.position.z;
    const double dx = x1 - x0;
    const double dy = y1 - y0;
    const double dz = z1 - z0;
    const double dist = sqrt(dx * dx + dy * dy + dz * dz);
    // double v = std::max(std::fabs(decceleration_factor * path.waypoints.at(i).twist.twist.linear.x), 1.0);
    double v = decceleration_factor * path.waypoints.at(i).twist.twist.linear.x;
    v = v < 1 ? path.waypoints.at(i).twist.twist.linear.x : v; // 减速调整航向角的操作仅在大于1时操作
    last_deccel_factor_ = decceleration_factor;
    v = std::max(v, (last_velocity_ - 0.05));
    last_velocity_ = v;
    path.waypoints.at(i).twist.twist.linear.x = v;
    // printf("v %f\n", v);
    t += (dist / v);
    path_time.push_back(t);
  }
}
```

calcPathRelativeTime函数用来生成路径点的时间序列path_time,在for循环中先得到第一个点（x<sub>0</sub>,y<sub>0</sub>,z<sub>0</sub>),和第二个点的坐标（x<sub>1</sub>,y<sub>1</sub>,z<sub>1</sub>)，随后计算两点之间的距离dist，利用距离dist与速度v的关系计算两点之间的时间差$\Delta t$,其中，速度v是第一点（两点中的前一点）的速度与1之间的1之间的较大值，最后更新时间是t+$\Delta t$,把更新完的时间放进时间序列path_time中直至到最后一点，得到一个对应于路径点序列的时间序列



**（2）重采样获得初步轨迹**

输入：current_points_:当前路径（path);

relative_time:时间序列（path_time);

traj_resample_disi_:重采样距离（d_ref_index=0.1)

输出：

traj:参考的轨迹（ref_traj)

```c++
void MPCUtils::convertWaypointsToMPCTrajWithDistanceResample(const autoware_msgs::Lane &path, const std::vector<double> &path_time,
                                                             const double &dl, MPCTrajectory &ref_traj)
{
  ref_traj.clear();
  double dist = 0.0;
  std::vector<double> dists;
  dists.push_back(0.0);

  for (int i = 1; i < (int)path_time.size(); ++i)
  {
    double dx = path.waypoints.at(i).pose.pose.position.x - path.waypoints.at(i - 1).pose.pose.position.x;
    double dy = path.waypoints.at(i).pose.pose.position.y - path.waypoints.at(i - 1).pose.pose.position.y;
    dist += sqrt(dx * dx + dy * dy);
    dists.push_back(dist);
  }

  convertWaypointsToMPCTrajWithResample(path, path_time, dists, dl, ref_traj);
}
```

convertWaypointsToMPCTrajWithDistanceResample函数与calcPathRelativeTime函数相似，不同之处在于前者得到的是相对距离序列dists（表示的是各点到第一个点的距离，此序列中的数据单调递增）,后者得到的是相对时间序列。

随后得到的**convertWaypointsToMPCTrajWithResample**函数分析如下：

输入：

current_waypoints_:当前路径（path);

relative_time:时间序列（path_time);

dists:距离序列（ref_index)

traj_resample_dist_:重采样距离（d_ref_index=0.1)

输出：

traj:**参考轨迹（ref_traj)**

```c++
void MPCUtils::convertWaypointsToMPCTrajWithResample(const autoware_msgs::Lane &path, const std::vector<double> &path_time,
                                                     const std::vector<double> &ref_index, const double &d_ref_index, MPCTrajectory &ref_traj)
{
  if (ref_index.size() == 0) {
    return;
  }

  for (unsigned int i = 1; i < ref_index.size(); ++i)
  {
    if (ref_index[i] < ref_index[i - 1])
    {
      ROS_ERROR("[convertWaypointsToMPCTrajWithResample] resampling index must be monotonically increasing. idx[%d] = %f, idx[%d+1] = %f",
                i, ref_index[i], i, ref_index[i + 1]);
      return;
    }
  }

  double point = ref_index[0];
  while (point < ref_index.back())
  {
    unsigned int j = 1;
    while (point > ref_index.at(j))
    {
      ++j;
    }
   //根据当前点在参考索引中的位置和路径上的两个邻近点的信息，计算出当前点的位置(x, y, z)，偏航角(yaw)，线速度(vx)，以及其他参数(curvature_tmp, t)
    const double a = point - ref_index.at(j - 1);
    const double ref_index_dist = ref_index.at(j) - ref_index.at(j - 1);
    const geometry_msgs::Pose pos0 = path.waypoints.at(j - 1).pose.pose;
    const geometry_msgs::Pose pos1 = path.waypoints.at(j).pose.pose;
    const geometry_msgs::Twist twist0 = path.waypoints.at(j - 1).twist.twist;
    const geometry_msgs::Twist twist1 = path.waypoints.at(j).twist.twist;
    const double x = ((ref_index_dist - a) * pos0.position.x + a * pos1.position.x) / ref_index_dist;
    const double y = ((ref_index_dist - a) * pos0.position.y + a * pos1.position.y) / ref_index_dist;
    const double z = ((ref_index_dist - a) * pos0.position.z + a * pos1.position.z) / ref_index_dist;

    /* for singular point of euler angle */
    const double yaw0 = tf2::getYaw(pos0.orientation);
    const double dyaw = amathutils::normalizeRadian(tf2::getYaw(pos1.orientation) - yaw0);
    const double yaw1 = yaw0 + dyaw;
    const double yaw = ((ref_index_dist - a) * yaw0 + a * yaw1) / ref_index_dist;
    const double vx = ((ref_index_dist - a) * twist0.linear.x + a * twist1.linear.x) / ref_index_dist;
    const double curvature_tmp = 0.0;
    const double t = ((ref_index_dist - a) * path_time.at(j - 1) + a * path_time.at(j)) / ref_index_dist;
    ref_traj.push_back(x, y, z, yaw, vx, curvature_tmp, t);
    point += d_ref_index;
  }
}
```

函数首先检查距离序列（ref_index)的尺寸不能为0，且必须单调递增。循环遍历当前路径(path)中所有的点，进行以距离d_ref_index=0.1的重采样，组成新的参考轨迹（ref_traj),包含坐标位置，横摆角，速度，时间等信息。（通过路径插值，生成新的轨迹）



计算x的坐标可以转化成下式：
$$
x=(1-\varepsilon )x_{0} +\varepsilon x_{1} 
$$
其中$\varepsilon$=a/ref_index_d

**可以看出此步骤本质是在插值增点，其他参数也是同理。完成此步最终得到重新采样后的轨迹。**

插值增点：给定n个横纵坐标互不相同的点i=1,2......n，构造次数为n的多项式，令其图像恰好经过n个点



**（3）计算航向角**

输入：

traj:参考的轨迹(traj)

输出：

计算轨迹中的航向角

```c++
void MPCUtils::calcTrajectoryYawFromXY(MPCTrajectory &traj)
{
  if (traj.yaw.size() == 0)
    return;

  for (unsigned int i = 1; i < traj.yaw.size() - 1; ++i)
  {
    const double dx = traj.x[i + 1] - traj.x[i - 1];
    const double dy = traj.y[i + 1] - traj.y[i - 1];
    traj.yaw[i] = std::atan2(dy, dx);
  }
  if (traj.yaw.size() > 1)
  {
    traj.yaw[0] = traj.yaw[1];
    traj.yaw.back() = traj.yaw[traj.yaw.size() - 2];
  }
}
```

函数首先检查轨迹中航向角序列（traj.yaw)的尺寸不能为0；随后根据x和y坐标的几何关系计算当前轨迹(traj)中的第二点和倒数第二点中各点的航向角，其范围约束在(-180,180),其中第一点和最后一点的航向角分别赋予第二点和倒数第二点的值

（4）计算曲率

```c++
void MPCUtils::calcTrajectoryCurvature(MPCTrajectory &traj, int curvature_smoothing_num)
{
  unsigned int traj_k_size = traj.x.size();
  traj.k.clear();

  /* calculate curvature by circle fitting from three points */
  geometry_msgs::Point p1, p2, p3;
  for (unsigned int i = curvature_smoothing_num; i < traj_k_size - curvature_smoothing_num; ++i)
  {
    p1.x = traj.x[i - curvature_smoothing_num];
    p2.x = traj.x[i];
    p3.x = traj.x[i + curvature_smoothing_num];
    p1.y = traj.y[i - curvature_smoothing_num];
    p2.y = traj.y[i];
    p3.y = traj.y[i + curvature_smoothing_num];
    double den = std::max(amathutils::find_distance(p1, p2) * amathutils::find_distance(p2, p3) * amathutils::find_distance(p3, p1), 0.0001);
    const double curvature = 2.0 * ((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)) / den;
    traj.k.push_back(curvature);
  }
```

这段代码用于计算轨迹的曲率。它使用三点圆拟合的方法，从给定的轨迹中的点坐标(traj.x, traj.y)计算曲率，并将结果保存在traj.k中。

代码首先定义了一个变量traj_k_size，用于表示轨迹点的数量。然后清空存储曲率的数组traj.k。

接下来，通过一个循环遍历轨迹中的每个点，从第curvature_smoothing_num个点到倒数第curvature_smoothing_num个点（这是为了确保有足够的邻近点进行曲率计算）。

对于每个点，从轨迹中取出相邻的三个点的坐标，分别表示为p1、p2和p3。然后计算曲率，公式为2乘以((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x))除以最大化的(p1、p2和p3之间距离的乘积)，这里用std::max函数确保除数不为零。

最后，将计算得到的曲率值curvature添加到traj.k数组中。



### 2.callbackPose函数

接收current_pose话题的回调函数

![image-20231020170759354](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231020170759354.png)

```c++
void MPCFollower::callbackPose(const geometry_msgs::PoseStamped::ConstPtr &msg)
{
  vehicle_status_.header = msg->header;
  vehicle_status_.pose = msg->pose;//车辆pose信息
  my_position_ok_ = true;//pose信息接受成功标志位
};
```

回调函数把接收到的车辆的当前位姿消息传递赋值给vehicle_status_并设置标志变量my_position_ok_为ok,表示成功接收到车辆的位姿信息

```c++
 struct VehicleStatus
  {
    std_msgs::Header header;    //< @brief header
    geometry_msgs::Pose pose;   //车辆位姿
    geometry_msgs::Twist twist; //车辆速度
    double tire_angle_rad;      //车辆轮胎转角
  };
```



### 3.callbackVehicleStatus函数

接收vehicle_status话题的回调函数

![image-20231020174411213](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231020174411213.png)

```c++
void MPCFollower::callbackVehicleStatus(const autoware_msgs::VehicleStatus &msg)
{
  vehicle_status_.tire_angle_rad = msg.angle;//当前转向角
  vehicle_status_.twist.linear.x = amathutils::kmph2mps(msg.speed);//当前车速
  my_steering_ok_ = true;//转向角信息接收成功标志位
  my_velocity_ok_ = true;//速度信息接收成功标志位
};
```

回调函数把接收到的车辆当前状态消息传递赋值给vehicle_status_并设置标准变量my_steering_ok_和my_velocity_ok_的值为true,表明成功接收到车辆的状态信息



### 4.定时器的回调函数

![image-20231020174958235](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231020174958235.png)

```c++
void MPCFollower::timerCallback(const ros::TimerEvent &te)
{

  /* guard */
  //如果模型和优化方法为空，则发送制动指令
  if (vehicle_model_ptr_ == nullptr || qpsolver_ptr_ == nullptr)
  {
    DEBUG_INFO("[MPC] vehicle_model = %d, qp_solver = %d", !(vehicle_model_ptr_ == nullptr), !(qpsolver_ptr_ == nullptr));
    publishControlCommands(0.0, 0.0, steer_cmd_prev_, 0.0); // publish brake
    return;
  }

  if (ref_traj_.size() == 0 || !my_position_ok_ || !my_velocity_ok_ || !my_steering_ok_)
   //如果接受到的路径信息为空，且接收不到车辆的位姿信息，则发送制动指令
  {
    DEBUG_INFO("[MPC] MPC is not solved. ref_traj_.size() = %d, my_position_ok_ = %d,  my_velocity_ok_ = %d,  my_steering_ok_ = %d",
               ref_traj_.size(), my_position_ok_, my_velocity_ok_, my_steering_ok_);
    publishControlCommands(0.0, 0.0, steer_cmd_prev_, 0.0); // publish brake
    return;
  }
  if (current_behavior_ == 0) // INITIAL_STATE
  {
    publishControlCommands(0.0, 0.0, steer_cmd_prev_, 0.0); // publish brake
    return;
  }

  /* control command */
  //控制命令初始化
  double vel_cmd = 0.0;
  double acc_cmd = 0.0;
  double steer_cmd = 0.0;
  double steer_vel_cmd = 0.0;

  /* solve MPC */
  //mpc求解并发布计算结果
  auto start = std::chrono::system_clock::now();
  const bool mpc_solved = calculateMPC(vel_cmd, acc_cmd, steer_cmd, steer_vel_cmd);
  double elapsed_ms = std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now() - start).count() * 1.0e-6;
  DEBUG_INFO("[MPC] timerCallback: MPC calculating time = %f [ms]\n", elapsed_ms);

  /* publish computing time */
  std_msgs::Float32 mpc_calc_time_msg;
  mpc_calc_time_msg.data = elapsed_ms;
  pub_debug_mpc_calc_time_.publish(mpc_calc_time_msg);

  if (!mpc_solved)
  {
    ROS_WARN("[MPC] MPC is not solved. publish 0 velocity.");
    vel_cmd = 0.0;
    acc_cmd = 0.0;
    steer_cmd = steer_cmd_prev_;
    steer_vel_cmd = 0.0;
  }

  publishControlCommands(vel_cmd, acc_cmd, steer_cmd, steer_vel_cmd);
};

```

timerCallback函数首先检查汽车模型和求解器对应的指针是否定义，参考路径，车辆速度，车辆配置，轮胎转角是否满足要求，有问题就会发布制动命令。随后获取系统当前时间并通过caculateMPC函数进行模型预测控制的相关计算，最后计算MPC所用的时间并发布出去，如果mpc求解成功，那么发布的控制指令就是

mpc求解的结果，如果mpc求解不成功，那么发布的控制指令就是使得小车不动.



####  (1)MPC计算

​         calculateMPC函数对参数进行读取，如预测时域、采样时间、当前车辆得横摆角等。接着寻找在参考轨迹中与车辆当前位置最近点，首先找到满足条件得最近点，再寻找第二近点。随后根据这两点的关系线性插值得到真正的最近点，，如下面的calcNearestPoseInterp函数。

​       检查计算的横向误差是否大于允许值，其中，MPC预测时间不能大于参考路径的相对时间，然后进行模型预测求解。

​       最后把MPC计算的时间发布出去。

**（1）calcNearestPoseInterp（寻找参考路径最近点函数）**

输入：

ref_traj_:参考路径(traj)

vehicle_status.pose:车辆自身位姿(self_pose)

输出：

nearest_pose:最近点位姿

nearest_index:在参考路径中的下标

dist_err:最近点与当前车辆位置的距离

yaw_err:最近点与当前车辆的横摆角误差

nearest_traj_time:最近点在路径中的时间

```c++
bool MPCUtils::calcNearestPoseInterp(const MPCTrajectory &traj, const geometry_msgs::Pose &self_pose, geometry_msgs::Pose &nearest_pose,
                                     unsigned int &nearest_index, double &min_dist_error, double &nearest_yaw_error, double &nearest_time)
{

  if (traj.size() == 0)
  {
    ROS_WARN("[calcNearestPoseInterp] trajectory size is zero");
    return false;
  }
  const double my_x = self_pose.position.x;
  const double my_y = self_pose.position.y;
  const double my_yaw = tf2::getYaw(self_pose.orientation);

  int nearest_index_tmp = -1;
  double min_dist_squared = std::numeric_limits<double>::max();
  for (uint i = 0; i < traj.size(); ++i)
  {
    const double dx = my_x - traj.x[i];
    const double dy = my_y - traj.y[i];
    const double dist_squared = dx * dx + dy * dy;

    /* ignore when yaw error is large, for crossing path */
    const double err_yaw = amathutils::normalizeRadian(my_yaw - traj.yaw[i]);
    if (fabs(err_yaw) < (M_PI / 3.0))
    {
      if (dist_squared < min_dist_squared)
      {
        /* save nearest index */
        min_dist_squared = dist_squared;
        nearest_index_tmp = i;
      }
    }
  }
  if (nearest_index_tmp == -1)
  {
    ROS_WARN("[calcNearestPoseInterp] yaw error is over PI/3 for all waypoints. no closest waypoint found.");
    return false;
  }

  nearest_index = nearest_index_tmp;

  if (traj.size() == 1)
  {
    nearest_pose.position.x = traj.x[nearest_index];
    nearest_pose.position.y = traj.y[nearest_index];
    tf2::Quaternion q;
    q.setRPY(0, 0, traj.yaw[nearest_index]);
    nearest_pose.orientation = tf2::toMsg(q);
    nearest_time = traj.relative_time[nearest_index];
    min_dist_error = std::sqrt(min_dist_squared);
    // nearest_index = (nearest_index + 10) < traj.yaw.size() ? (nearest_index + 10) : nearest_index;
    nearest_yaw_error = amathutils::normalizeRadian(my_yaw - traj.yaw[nearest_index]);
    return true;
  }

  /* get second nearest index = next to nearest_index */
  int second_nearest_index = 0;
  if (nearest_index == traj.size() - 1)
    second_nearest_index = nearest_index - 1;
  else if (nearest_index == 0)
    second_nearest_index = 1;
  else
  {
    double dx1, dy1, dist_squared1, dx2, dy2, dist_squared2;
    dx1 = my_x - traj.x[nearest_index + 1];
    dy1 = my_y - traj.y[nearest_index + 1];
    dist_squared1 = dx1 * dx1 + dy1 * dy1;
    dx2 = my_x - traj.x[nearest_index - 1];
    dy2 = my_y - traj.y[nearest_index - 1];
    dist_squared2 = dx2 * dx2 + dy2 * dy2;
    if (dist_squared1 < dist_squared2)
      second_nearest_index = nearest_index + 1;
    else
      second_nearest_index = nearest_index - 1;
  }

  const double a_sq = min_dist_squared;

  /* distance between my position and second nearest position */
  const double dx2 = my_x - traj.x[second_nearest_index];
  const double dy2 = my_y - traj.y[second_nearest_index];
  const double b_sq = dx2 * dx2 + dy2 * dy2;

  /* distance between first and second nearest position */
  const double dx3 = traj.x[nearest_index] - traj.x[second_nearest_index];
  const double dy3 = traj.y[nearest_index] - traj.y[second_nearest_index];
  const double c_sq = dx3 * dx3 + dy3 * dy3;

  /* if distance between two points are too close */
  if (c_sq < 1.0E-5)
  {
    nearest_pose.position.x = traj.x[nearest_index];
    nearest_pose.position.y = traj.y[nearest_index];
    tf2::Quaternion q;
    q.setRPY(0, 0, traj.yaw[nearest_index]);
    nearest_pose.orientation = tf2::toMsg(q);
    nearest_time = traj.relative_time[nearest_index];
    min_dist_error = std::sqrt(min_dist_squared);
    // nearest_index = (nearest_index + 10) < traj.yaw.size() ? (nearest_index + 10) : nearest_index;
    nearest_yaw_error = amathutils::normalizeRadian(my_yaw - traj.yaw[nearest_index]);
    return true;
  }

  /* linear interpolation */
  const double alpha = 0.5 * (c_sq - a_sq + b_sq) / c_sq;
  nearest_pose.position.x = alpha * traj.x[nearest_index] + (1 - alpha) * traj.x[second_nearest_index];
  nearest_pose.position.y = alpha * traj.y[nearest_index] + (1 - alpha) * traj.y[second_nearest_index];
  double tmp_yaw_err = traj.yaw[nearest_index] - traj.yaw[second_nearest_index];
  if (tmp_yaw_err > M_PI)
  {
    tmp_yaw_err -= 2.0 * M_PI;
  }
  else if (tmp_yaw_err < -M_PI)
  {
    tmp_yaw_err += 2.0 * M_PI;
  }
  const double nearest_yaw = traj.yaw[second_nearest_index] + alpha * tmp_yaw_err;
  tf2::Quaternion q;
  q.setRPY(0, 0, nearest_yaw);
  nearest_pose.orientation = tf2::toMsg(q);
  nearest_time = alpha * traj.relative_time[nearest_index] + (1 - alpha) * traj.relative_time[second_nearest_index];
  min_dist_error = std::sqrt(b_sq - c_sq * alpha * alpha);
  nearest_yaw_error = amathutils::normalizeRadian(my_yaw - nearest_yaw);
  return true;
}
```

calcNearestPoseInterp函数的作用是利用线性插值方式计算出在参考路径点序列（Traj)中与当前车辆位置最近的点nearest_pose（类型:geometry_msgs:pose)。在获取车辆当前位姿状态my_x(x坐标)、my_y(y坐标)、my_yaw（横摆角）后利用for循环遍历路径序列中的点，根据平面几何关系计算出当前位置到路径点上的距离的平方dist_squared,随后根据amathutils::normalizeRadian函数计算出当前位置与路径点的横摆角误差err_yaw,函数如下：

```c++
double normalizeRadian(const double _angle)
{
  double n_angle = std::fmod(_angle, 2 * M_PI);
  n_angle = n_angle > M_PI ? n_angle - 2 * M_PI : n_angle < -M_PI ? 2 * M_PI + n_angle : n_angle;

  // another way
  // Math.atan2(Math.sin(_angle), Math.cos(_angle));
  return n_angle;
}
```

normalizeRadian函数主要实现把横摆角误差表示在一个$\pm $180°范围内

在前面已经得到路径点与当前位姿的关系，下面进行判断哪种关系是合格的进而得到最近点

1. 首先err_yaw（横摆角误差）的绝对值要小于Π/3，在满足横摆角要求的点中找到距离最近的点便是最近点，把下标i赋值给nearest_index_tmp（临时最近点下标）；

2. 接着获取第二近点，根据上面步骤中的最近点（不是参考轨迹的第一点或者最后一点的时候）向前后各找一点，选取车辆当前位置与这两点中距离较近的一点作为第二近点，同时得到当前位置到最近点的距离的平方（a_sq),到第二近点距离的平方（b_sq),最近点到第二近点距离的平方（c_sq)

3. 最终根据上述两点（存在一定间距）线性插值得到nearest_pose,线性插值的参数alpha根据a_sq,b_sq,c_sq获得，插值方式与前面处理路径点同理。

   计算完成后将会得到最近参考点的位姿、下标、横摆角误差、相对时间等。



**（2）模型预测求解**

根据代码看到系统的模型状态量为：

1. 横向距离误差err_lat;
2. 航向角误差yaw_err;
3. 轮胎当前转角steer

其中，横向误差计算如下：

![image-20231021120543677](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231021120543677.png)

定义a为我们所求的横向误差err_lat,$\varphi $为最近点的航向角

所以有：
$$
a=y*cos\varphi -x*sin\varphi
$$


####  (2)publishControlCommands函数

```c++
void MPCFollower::publishControlCommands(const double &vel_cmd, const double &acc_cmd,
                                         const double &steer_cmd, const double &steer_vel_cmd)
{
  const double omega_cmd = vehicle_status_.twist.linear.x * std::tan(steer_cmd) / wheelbase_;
  if (output_interface_ == "twist")
  {
    publishTwist(vel_cmd, omega_cmd);
  }
  else if (output_interface_ == "ctrl_cmd")
  {
    publishCtrlCmd(vel_cmd, acc_cmd, steer_cmd);
  }
  else if (output_interface_ == "all")
  {
    publishTwist(vel_cmd, omega_cmd);
    publishCtrlCmd(vel_cmd, acc_cmd, steer_cmd);
  }
  else
  {
    ROS_WARN("[MPC] control command interface is not appropriate");
  }
}
```

publishControlCommands函数用来发布控制指令，output_interface_参数的值为all，因此会发布vel_cmd(速度)、omega_cmd(车辆的角速度)、acc_cmd(加速度)、steer_cmd(转向角),其中，omega_cmd(车辆的角速度)在此函数中求得：
$$
w=v/(\frac{tan(\delta )}{L} )=v/R
$$
至此我们已经得到跟踪轨迹需要得车辆控制量

## 3.5 添加mpc进入工程

**1.程序部署：先修改 robot_monitor 程序，增加mpc规划选项，选择mpc选项后，启动相应的程序(完成)**

问题存在：

1.打开仿真导航按键后，控制方案选择的是mpc，但是并没有发布mpc的话题，仍然是在发布velocity_smoother的话题（解决）



**2.程序开发： 基于导航类型和模式修改mpc程序内部的订阅和发布，使得发布信息和velocity的一样，达到订阅相应信息，输出速度信息**

1.问题：为什么 /plt_cmd_vel话题没有数据输出？

/smoother_cmd_vel发布数据

2.为什么使用mpc方案后，/smoother_cmd_vel节点仍然发布速度信息



3.需要了解局部路径/move_base/TrajectoryPlannerROS/global_plan发布的路径是什么数据格式的，它需要将autoware_msgs::Lane类型的路径进行替换



**3.修改mpc内部程序，使得其兼容现有机器人方案**





**4.添加纵向控制到MPC中**

思路：使用pid算法单独控制纵向速度





## 3.5 MPC需要的数学知识

参考资料：[自动驾驶控制算法实例之模型预测控制（MPC）--从模型推导到代码实现（以Autoware为例） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/358836526)



##### 1.线性插值 



##### 2.二次规划问题求解



##### 3.离散化用到的双线性变换和欧拉变换



# 四、PID控制

参考资料：[Apollo开发者社区_Apollo星火计划之PnC专项 (baidu.com)](https://apollo.baidu.com/community/course/outline/12?activeId=956)

https://zhuanlan.zhihu.com/p/390987569

https://zhuanlan.zhihu.com/p/617633474

## 1.PID算法介绍

在对系统不能建模的情况下，pid是一个很不错的控制方法

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231028175942600.png" alt="image-20231028175942600" style="zoom:50%;" />



比例项：比例项太大，会导致系统不稳定，比例项太小，会导致对于系统扰动时，控制作用太小（只有比例项时，会导致稳态误差）

![image-20231123180417637](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231123180417637.png)

积分项：对误差一段时间的累积，容易导致超调量，用于消除稳态误差

![image-20231123181238196](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231123181238196.png)67

微分项：提升系统收敛的时间和稳定性（抑制比例和积分项），抑制超调量（微分项具有预测作用）

![image-20231123181549554](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231123181549554.png)







位置式和增量式PID

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231028180127891.png" alt="image-20231028180127891" style="zoom:67%;" />

![image-20231028180145162](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231028180145162.png)

**apollo代码中pid结构**

速度控制器

![image-20231028180356159](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231028180356159.png)

调参经验：

![image-20231028180538211](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231028180538211.png)

Ki的调节

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231028180738627.png" alt="image-20231028180738627" style="zoom:67%;" />

Kd对应偏差较为灵敏

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231028180952149.png" alt="image-20231028180952149" style="zoom:50%;" />

三个参数调节的效果：

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231028181213812.png" alt="image-20231028181213812" style="zoom:67%;" />



在apollo代码介绍

![image-20231028181843070](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231028181843070.png)

```c++
//位置式pid
double PIDController::Control(const double error, const double dt) {
  if (dt <= 0) {
    AWARN << "dt <= 0, will use the last output, dt: " << dt;
    return previous_output_;
  }
  double diff = 0;
  double output = 0;

  if (first_hit_) {
    first_hit_ = false;
  } else {
    diff = (error - previous_error_) / dt;
  }
  // integral hold
  /*
  积分幅值判断：高于积分饱和上限，则等于积分饱和上限，并将积分饱和状态置1；
  低于积分饱和下限，则等于积分饱和下限，并将积分饱和状态置-1；
  其余情况积分饱和状态置0；
  */
  if (!integrator_enabled_) {
    integral_ = 0;
  } else if (!integrator_hold_) {
    integral_ += error * dt * ki_;
    // apply Ki before integrating to avoid steps when change Ki at steady state
    if (integral_ > integrator_saturation_high_) {
      integral_ = integrator_saturation_high_;
      integrator_saturation_status_ = 1;
    } else if (integral_ < integrator_saturation_low_) {
      integral_ = integrator_saturation_low_;
      integrator_saturation_status_ = -1;
    } else {
      integrator_saturation_status_ = 0;
    }
  }
  previous_error_ = error;
  output = error * kp_ + integral_ + diff * kd_;  // Ki already applied
  previous_output_ = output;
  return output;
}

```



![image-20231028192935052](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231028192935052.png)

![image-20231106170652973](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231106170652973.png)



## 2.apoll的加速度控制命令计算

![img](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/v2-b7a28e34fef71bcc79510fc1859655fb_r.jpg)

![image-20231123112215540](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231123112215540.png)

## 3.积分饱和

参考资料：https://docs.pingcode.com/ask/ask-ask/197726.html

​       **积分饱和**（Integral windup或integrator windup[[1\]](https://zh.wikipedia.org/wiki/積分飽和#cite_note-1)）是指[PID控制器](https://zh.wikipedia.org/wiki/PID控制器)或是其他有[积分器](https://zh.wikipedia.org/wiki/積分器)的控制器中的现象，是指误差有大幅变化（例如大幅增加），积分器因为误差的大幅增加有很大的累计量，因此造成[过冲](https://zh.wikipedia.org/wiki/过冲)，**而且当误差变为负时**，其过冲仍维持一段时间之后才恢复正常的情形。

​       简言之，PID控制算法中的积分项是用来消除静态误差的，它通过对误差信号进行累积来增强控制效果。然而，当控制器尝试调整到理想状态时，如果存在持续的误差，积分项会不断累积这些误差，一旦累积结果超出控制器输出的最大限度，就会发生积分饱和现象。

<img src="https://cdn.jsdelivr.net/gh/su-ron/image/imgv2-39d427d6afa900c28c772d38f7f53da3_1440w.webp" alt="img" style="zoom:80%;" />

### 3.1 产生原因

积分饱和现象的产生原因主要有两个方面：

一是**系统长时间偏离设定值**

二是**积分项的增益设置过高**。

当系统长时间处于偏离设定点的状态下，PID控制器中的积分项会累积较大的误差值，若此时积分增益过大，将会导致控制器输出迅速增加，最终超过系统所能承受的最大输出限制，产生饱和。

首先，系统长时间偏离设定值是积分饱和的直接原因。在实际应用中，如温度控制、速度控制等场合，受外界干扰或系统本身的非线性特性影响，系统可能无法迅速准确地回到设定值，这种持续的偏差会被积分环节连续累积，导致输出的调整量越来越大，进而引起输出限幅，即发生了所谓的积分饱和。



### 3.2 积分饱和现象的影响

积分饱和现象对PID控制系统的影响是全面且负面的，**主要表现为控制系统的响应时间延长、超调增加、以及稳定性变差**。这些影响最终将导致系统性能的大幅度下降，严重时甚至可能因为控制器输出信号的持续错误导致系统失稳。

一方面，**响应时间延长**是积分饱和现象的直接后果。积分饱和导致控制器输出达到上限，而实际系统可能因为没有收到足够的调整而无法快速回应设定值变化，从而导致系统达到新的稳态所需要的时间变长。



### 3.3 解决方法

普遍的方法包括：设置积分项的饱和限制、引入积分分离技术、以及采用积分预置技术等。



**1.引入积分分离技术**

​        积分分离技术是一种智能的解决方法，它通过判断系统的状态来决定是否启用积分项。当误差大于设定的阈值时，暂时关闭积分功能，避免误差过大时积分的累积；误差小于阈值时再启用积分项。这种方法既保证了系统快速响应大误差，又避免了因积分累积导致的饱和问题。

​        通过以上介绍，我们可以理解到，**积分饱和现象是PID控制中一个必须关注并妥善解决的问题**。只有准确掌握其产生的原因、了解其对系统性能的影响，并采用有效的策略来避免或减轻其负面影响，才能确保PID控制系统的稳定性和优良性能。

![img](https://cdn.jsdelivr.net/gh/su-ron/image/imgv2-e1694f30245db193c903706121f2b1c6_1440w.webp)

首先比较饱和检查前后PID控制器的输出；如果值相等，则没有发生饱和，该块输出0；如果值不相等，则发生饱和，该块输出为1；

第二个检查是比较控制器的符号；如果误差和控制器的输出均为正值，那么就知道积分器仍在对输出进行加法，以使其变得更加正值；

然后将两个比较的结果与起来，从而来对积分环节进行控制.







**2.设置积分项的饱和限制**

为控制器的积分项设置一个饱和门限是解决积分饱和最直接的方法。通过软件编程设定一个积分输出的最大值，一旦积分项的累积误差达到这个阈值，就不再增加，从而避免了积分项导致的输出饱和。这种方法虽然简单直接，但可能会在一定程度上牺牲控制精度。







## 4.PID仿真

网址：

https://f1tenth.org/learn.html

https://docs.tianbot.com/

https://docs.tianbot.com/manual/tianracer/

仿真平台：[tianbot/tianbot_mini: TianbotMini ROS移动机器人学习平台，10分钟跑通机器人SLAM应用，自主导航尽在掌心之中。 (github.com)](https://github.com/tianbot/tianbot_mini)

f1模型：[F1TENTH Simulator — F1TENTH - Build latest documentation](https://f1tenth.readthedocs.io/en/stable/going_forward/simulator/index.html)

[Learn (f1tenth.org)](https://f1tenth.org/learn.html)

f1参考教程：[PID算法在ROS仿真环境中的理论及应用（ROS_F1TENTH）_https://github.com/grizi-ju/ros_program-CSDN博客](https://blog.csdn.net/weixin_52029211/article/details/122952112?ops_request_misc=%7B%22request%5Fid%22%3A%22170072527416800213010776%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=170072527416800213010776&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-122952112-null-null.142^v96^pc_search_result_base6&utm_term=pid算法在ros仿真环境&spm=1018.2226.3001.4187)

创建功能包指令：

```c++
catkin_create_pkg wall_following_pid roscpp rospy std_msgs
```

师兄建议：wall follower沿墙控制方案，开源的可以放在我们机器上集成到我们qt上跑一跑，熟悉一下pid的控制之后在考虑做进去mpc

f1方程式仿真

实验效果：![image-20231123163221781](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231123163221781.png)

![image-20231127165917913](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231127165917913.png)

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231129162637862.png" alt="image-20231129162637862" style="zoom:50%;" />

角度转换成角速度关键公式

```c++
        //转换公式 求解角速度
        const double omega_cmd = yuanpan_drive_result.linear.x * std::tan(yuanpan_drive_result.angular.z) / wheelbase_;
```



### 1.在圆盘中添加pid

**参考小巨同学的沿墙跑方案**

1.把规划方案的velocity_smoother包替换掉

velocity_smoother节点图

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231124155745772.png" alt="image-20231124155745772" style="zoom: 67%;" />

pid方案提供的是线速度和角度，但是替换的velocity_smoother需要的是线速度和角速度

**需要参考MPC方案来进行转换**

```c++
void MPCFollower::publishControlCommands(const double &vel_cmd, const double &acc_cmd,
                                         const double &steer_cmd, const double &steer_vel_cmd)
{
  const double omega_cmd = vehicle_status_.twist.linear.x * std::tan(steer_cmd) / wheelbase_;
  if (output_interface_ == "twist")
  {
    publishTwist(vel_cmd, omega_cmd);
  }
  else if (output_interface_ == "ctrl_cmd")
  {
    publishCtrlCmd(vel_cmd, acc_cmd, steer_cmd);
  }
  else if (output_interface_ == "all")
  {
    publishTwist(vel_cmd, omega_cmd);
    publishCtrlCmd(vel_cmd, acc_cmd, steer_cmd);
  }
  else
  {
    ROS_WARN("[MPC] control command interface is not appropriate");
  }
}
```



圆盘轮距：

![image-20231126205503823](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231126205503823.png)



### 2.turtlebot3仿真环境

资料：[海龟机器人3 (robotis.com)](https://emanual.robotis.com/docs/en/platform/turtlebot3/slam_simulation/)

[ROBOTIS-GIT/turtlebot3: ROS packages for Turtlebot3 (github.com)](https://github.com/ROBOTIS-GIT/turtlebot3)

[VMware: vmw_ioctl_command error 无效的参数.-CSDN博客](https://blog.csdn.net/sinat_21123835/article/details/105361737?ops_request_misc=%7B%22request%5Fid%22%3A%22170105704016800182170323%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&request_id=170105704016800182170323&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-105361737-null-null.142^v96^pc_search_result_base6&utm_term=VMware%3A vmw_ioctl_command error 无效的参数. Aborted (core dumped) [gazebo_gui-3] process has died [pid 2226%2C exit code 134%2C cmd %2Fopt%2Fros%2Fmelodic%2Flib%2Fgazebo_ros%2Fgzclient __name%3A%3Dgazebo_gui __log%3A%3D%2Fhome%2Fsu%2F.&spm=1018.2226.3001.4187)

![image-20231127160446656](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231127160446656.png)

打开gazebo

```
export SVGA_VGPU10=0
export TURTLEBOT3_MODEL=burger
roslaunch turtlebot3_gazebo turtlebot3_world1.launch
```

运行slam

```
export TURTLEBOT3_MODEL=burger
roslaunch turtlebot3_slam turtlebot3_slam.launch slam_methods:=gmapping
 rosrun map_server map_saver -f ~/map
```

运行键盘控制

```
 export TURTLEBOT3_MODEL=burger
 roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch
```

运行导航节点

```c++
export TURTLEBOT3_MODEL=burger
roslaunch turtlebot3_navigation turtlebot3_navigation.launch map_file:=$HOME/map.yaml
```

实验结果：

![image-20231127165939682](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231127165939682.png)



### 3.仿真参数调整

产生问题：

1.如何停止？

2.跟踪纵向误差？

3.如何调节pid参数？

思路：感觉需要把距离数据输出绘制曲线，才能调节曲线



**先参照apoll的pid_controller.cpp来对现在的代码进行重构**

实验参数与实验效果：

![image-20231128193533939](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231128193533939.png)

实验效果：在拐角处转弯不及时

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231128193816360.png" alt="image-20231128193816360" style="zoom:33%;" />

增大积分项kd能够明显改善在拐弯处的情况

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231128201841882.png" alt="image-20231128201841882" style="zoom:50%;" />





**在圆盘小车上实验**

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231129162637862.png" alt="image-20231129162637862" style="zoom:50%;" />



依然存在的问题是：

1.当距离大于设定值时，超调量过大



2.当转弯达到最大值的时候，原地转圈





### 4.pid控制机器人上充电桩

水平校准

![image-20231204205236599](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231204205236599.png)

垂直校准

![image-20231204205147014](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231204205147014.png)

其中

```c++
private_nh.param("angle_kp", angle_kp_, 2.0f);
private_nh.param("distance_kp", distance_kp_, 1.0f);
```



# 五.横向控制

![image-20231031164822056](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231031164822056.png)



## 5.1 三个坐标系与运动学方程

还差运动学方程的横向微分方程

控制的前提是路径规划

![image-20231031165223216](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231031165223216.png)



**三个坐标系**

![image-20231031165428293](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231031165428293.png)

混乱的来源：左手系和右手系

![image-20231031165857281](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231031165857281.png)

一般数学，物理学都是右手系

一般计算机图形学是左手系



**自行车模型**

自行车模型有三个假设：

1.左右对称

2.车的轮距可以忽略不记

3.车的轮子是个刚性轮子

![image-20231031170302132](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231031170302132.png)

不考虑轮胎的变形（运动学模型），考虑（动力学模型）

![image-20231031171005109](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231031171005109.png)

**运动学模型**

微分方程：

![image-20231031171440914](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231031171440914.png)

![image-20231031171404053](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231031171404053.png)

![image-20231031171912930](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231031171912930.png)

这里a+b/r少了cosB

质心距离：（a,b,hg),载重变化，这三都会发生变化，可以用力矩平衡来判断

（满载空载质心肯定会变，而且加速减速会有质心转移）

**运动学方程：**

![image-20231031172132177](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231031172132177.png)

在低速条件下，且后轮不转向

![image-20231031172208245](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231031172208245.png)

此时cosb=1,所以消去了



## 5.2 动力学方程

参考资料：[【基础】自动驾驶控制算法第三讲 轮胎侧偏与车辆动力学方程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1EZ4y1T7jG/?spm_id_from=333.788.recommend_more_video.-1&vd_source=e6a100138906f3892c6413488ca8e688)

![image-20231031174437389](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231031174437389.png)



![image-20231031175444123](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231031175444123.png)

运动学方程中，v和横摆角耦合在了一起

动力学方程实现了解耦

![image-20231031180306833](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231031180306833.png)

**二自由度车辆动力学方程**

![image-20231102113024349](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231102113024349.png)

轮胎的侧偏特性

<img src="C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231102113112021.png" alt="image-20231102113112021" style="zoom:67%;" />

**侧偏刚度**

![image-20231102113418207](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231102113418207.png)

**自行车模型**

<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231102113944064.png" alt="image-20231102113944064" style="zoom:50%;" />



<img src="https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231102114200988.png" alt="image-20231102114200988" style="zoom:50%;" />



a<sub>y</sub>与y的关系，以及a<sub>f</sub>,a<sub>r</sub>的具体表达式

![image-20231103202644634](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231103202644634.png)

由于de<sub>x</sub>/dt和de<sub>y</sub>求导不等于0，所以a<sub>y</sub>带个小尾巴

![image-20231103202951231](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231103202951231.png)



**对于后轮做运动学分解**

![image-20231103203901935](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231103203901935.png)

**对前轮做运动学分解**，

得到二自由度的动力学微分方程

![image-20231106144720523](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231106144720523.png)

![image-20231106145432788](C:/Users/su/AppData/Roaming/Typora/typora-user-images/image-20231106145432788.png)

**勘误：这里写错了，a<sub>y</sub>=v<sub>y</sub>应该是v<sub>y</sub>的导数而不是v<sub>y</sub>**

**第二个矩阵的第二个变量没有负号**

完成状态方程的计算







## **5.3  坐标变换和横向误差微分方程**

参考资料：[【基础】自动驾驶控制算法第四讲 坐标变换与横向误差微分方程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1GD4y1o7Vf/?spm_id_from=333.788.recommend_more_video.0&vd_source=e6a100138906f3892c6413488ca8e688)![](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231106153201139.png)

QR指的是二次型和调节器两个单词

![image-20231106153434488](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231106153434488.png)

**横向误差，航向误差和投影速度大小**

![image-20231106155117213](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231106155117213.png)

TAO是r的切线

![image-20231108174928526](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231108174928526.png)

所以：

![image-20231108174944347](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231108174944347.png)



**这dd/dt,ds/dt两个公式是理论的起点**

![image-20231108175004538](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231108175004538.png)

与运动学公式联系起来

![image-20231108175043641](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231108175043641.png)



![image-20231108175106565](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231108175106565.png)

![image-20231108175120288](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231108175120288.png)

把V<sub>y</sub>和横摆角的公式转化成横向误差的公式

![image-20231106165614950](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231106165614950.png)



![image-20231106165751811](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231106165751811.png)



简化：

![image-20231106170039719](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231106170039719.png)

转化成线性方程组

![image-20231106170238972](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231106170238972.png)

写成矩阵形式：（转化成线性方程组的形式）

![image-20231106170302648](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231106170302648.png)

**autoware的动力学模型**

上面的第三个矩阵好像有误，第三个矩阵的第二项少了一个k（曲率）

```c++
/*
 *    Representation
 * e      : lateral error
 * de     : derivative of lateral error
 * th     : heading angle error 
 * dth    : derivative of heading angle error 
 * steer  : steering angle (input)
 * v      : velocity 
 * m      : mass
 * Iz     : inertia
 * lf     : length from center to front tire
 * lr     : length from center to rear tire
 * cf     : front tire cornering power  前轮侧偏刚度（这里认为侧偏刚度是正数）
 * cr     : rear tire cornering power   后轮侧偏刚度
 * k      : curvature on reference trajectory point
 * 
 *    State & Input
 * x = [e, de, th, dth]^T
 * u = steer
 * 
 *    Linearized model around reference point (v=vr)
 *          [0,                   1,                0,                        0]       [       0]       [                          0]
 *  dx/dt = [0,       -(cf+cr)/m/vr,        (cf+cr)/m,       (lr*cr-lf*cf)/m/vr] * x + [    cf/m] * u + [(lr*cr-lf*cf)/m/vr*k - vr*k]
 *          [0,                   0,                0,                        1]       [       0]       [                          0]
 *          [0, (lr*cr-lf*cf)/Iz/vr, (lf*cf-lr*cr)/Iz, -(lf^2*cf+lr^2*cr)/Iz/vr]       [lf*cf/Iz]       [   -(lf^2*cf+lr^2*cr)/Iz/vr]
 * 
 * Reference : Jarrod M. Snider, "Automatic Steering Methods for Autonomous Automobile Path Tracking", Robotics Institute, Carnegie Mellon University, February 2009.
 */
```







还遗留着三个问题：

![image-20231106170450477](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231106170450477.png)



# 六、纵向控制

参考资料：[【基础】自动驾驶控制算法第九讲 纵向控制开篇_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1bp4y1673z/?spm_id_from=333.999.0.0&vd_source=e6a100138906f3892c6413488ca8e688)

[自动驾驶控制算法——横纵向误差计算-CSDN博客](https://blog.csdn.net/liumengxie/article/details/129908271?ops_request_misc=%7B%22request%5Fid%22%3A%22169943470216800184116455%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169943470216800184116455&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-129908271-null-null.142^v96^pc_search_result_base6&utm_term=纵向误差&spm=1018.2226.3001.4187)

1. //基本概念 预览点：当前时间加上预览时间在轨迹上对应的点，车辆将要到达的纵向位置
2. //基本概念 参考点：当前时间在轨迹上对应的点，车辆此刻应该到达的纵向位置
3. //基本概念 匹配点：当前时间距离轨迹上对应的最近点











# 七、部署autoware

## 1.遇到的问题

1.遇到最大的一个修改是在此处

![image-20231024174722780](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231024174722780.png)





2.查看话题，出现错误

参考：[【ROS基础一】5.Bug相关问题_no handlers could be found for logger "rosout-CSDN博客](https://blog.csdn.net/Boys_Wu/article/details/122231748?ops_request_misc=&request_id=&biz_id=102&utm_term=Cannot load message class for &utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-122231748.142^v96^pc_search_result_base6&spm=1018.2226.3001.4187)

![image-20231109105649495](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231109105649495.png)

需要

```c++
source devel/setup.bash
```





## 2.添加PID算法来进行纵向控制

在只能控制横向误差的情况下，autoware的MPC功能包存在两个问题：

1. 不能后退
2. **侧向动态特性未充分考虑**：MPC 只能控制横向误差，但在拐弯时，车辆的侧向动态特性也十分重要。如果侧向动态特性未被充分考虑，可能导致在拐弯时无法有效地控制车辆的姿态和轨迹，从而导致在拐弯处会出现飘出去

问题：

**1.梳理apoll的纵向pid控制是怎么实现的？**

参考资料：[【精选】Apollo星火计划学习笔记——第八讲Apollo控制模块解析与实践2_apollo纵向控制-CSDN博客](https://blog.csdn.net/sinat_52032317/article/details/128357889?ops_request_misc=&request_id=&biz_id=102&utm_term=apollo纵向控制算法&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-128357889.142^v96^pc_search_result_base6&spm=1018.2226.3001.4187)

**1.1输入是什么？输出是什么？**

![image-20231109145355833](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231109145355833.png)

![image-20231109113930314](https://cdn.jsdelivr.net/gh/su-ron/myBlogResource/freertos/picture/image-20231109113930314.png)



```c++
//算法主要部分：根据定位，底盘，规划信息计算输出指令cmd
Status LonController::ComputeControlCommand(
    const localization::LocalizationEstimate *localization,
    const canbus::Chassis *chassis,
    const planning::ADCTrajectory *planning_published_trajectory,
    control::ControlCommand *cmd)
```

**输入：**

**定位信息**

```c++
message LocalizationEstimate {
  optional apollo.common.Header header = 1;
  optional apollo.localization.Pose pose = 2;
  optional Uncertainty uncertainty = 3;

  // The time of pose measurement, seconds since 1970-1-1 (UNIX time).
  optional double measurement_time = 4;  // In seconds.

  // Future trajectory actually driven by the drivers
  repeated apollo.common.TrajectoryPoint trajectory_point = 5;

  // msf status
  optional MsfStatus msf_status = 6;
  // msf quality
  optional MsfSensorMsgStatus sensor_status = 7;
}
```

**底盘信息**

```c++
message Chassis {
  enum DrivingMode {
    COMPLETE_MANUAL = 0;  // human drive
    COMPLETE_AUTO_DRIVE = 1;
    AUTO_STEER_ONLY = 2;  // only steer
    AUTO_SPEED_ONLY = 3;  // include throttle and brake

    // security mode when manual intervention happens, only response status
    EMERGENCY_MODE = 4;
  }
```



**轨迹信息**

```c++
message ADCTrajectory {
  optional apollo.common.Header header = 1;

  optional double total_path_length = 2;  // in meters

  optional double total_path_time = 3;    // in seconds

  optional EStop estop = 6;

  optional apollo.planning_internal.Debug debug = 8;

  // is_replan == true mean replan triggered
  optional bool is_replan = 9 [default = false];

  // Specify trajectory gear
  optional apollo.canbus.Chassis.GearPosition gear = 10;

  // path data + speed data
  repeated apollo.common.TrajectoryPoint trajectory_point = 12;

  // path point without speed info
  repeated apollo.common.PathPoint path_point = 13;

  optional apollo.planning.DecisionResult decision = 14;

  optional LatencyStats latency_stats = 15;

  // the routing used for current planning result
  optional apollo.common.Header routing_header = 16;
  enum RightOfWayStatus {
    UNPROTECTED = 0;
    PROTECTED = 1;
  }
  optional RightOfWayStatus right_of_way_status = 17;

  // lane id along current reference line
  repeated apollo.hdmap.Id lane_id = 18;

  // set the engage advice for based on current planning result.
  optional apollo.common.EngageAdvice engage_advice = 19;

  // the region where planning cares most
  message CriticalRegion {
    repeated apollo.common.Polygon region = 1;
  }
  // critical region will be empty when planning is NOT sure which region is
  // critical
  // critical regions may or may not overlap
  optional CriticalRegion critical_region = 20;

  enum TrajectoryType {
    UNKNOWN = 0;
    NORMAL = 1;
    PATH_FALLBACK = 2;
    SPEED_FALLBACK = 3;
    PATH_REUSED = 4;
  }
  optional TrajectoryType trajectory_type = 21 [default = UNKNOWN];

  optional string replan_reason = 22;

  // lane id along target reference line
  repeated apollo.hdmap.Id target_lane_id = 23;

  // complete dead end flag
  optional bool car_in_dead_end = 24;

  // output related to RSS
  optional RSSInfo rss_info = 100;
}
```





**2.autoware中mpc并没有对速度和加速度进行控制，只是单纯地从base_waypoints和final_waypoints的路径点中获得**

在mpc_waypoints_converter.cpp中

```c++
    for (int i = base_start; i < closest_idx; ++i)
    {
      mpc_waypoints.waypoints.push_back(base_waypoints_.waypoints.at(i));
      mpc_waypoints.waypoints.back().twist = final_waypoints.waypoints[1].twist;
      mpc_waypoints.waypoints.back().twist.twist.linear.x=2.0;
    }

    int final_end = std::min(front_waypoints_num_ + 1, (int)final_waypoints.waypoints.size());
    for (int i = 1; i < final_end; ++i)
    {
      mpc_waypoints.waypoints.push_back(final_waypoints.waypoints.at(i));
      mpc_waypoints.waypoints.back().twist.twist.linear.x=2.0;
    }

    pub_waypoints_.publish(mpc_waypoints);
  }
```







11.21完成把pid_controller.cpp添加到mpc工程中